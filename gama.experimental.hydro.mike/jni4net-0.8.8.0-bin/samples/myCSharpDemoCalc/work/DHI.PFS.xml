<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DHI.PFS</name>
    </assembly>
    <members>
        <member name="T:DHI.PFS.PFSToken">
            <summary>
            Tokens that can occur in a PFS file.
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSToken.PfsEOF">
            <summary>
            End Of File token
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSToken.Section">
            <summary>
            Section definition, start of new section
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSToken.EndSection">
            <summary>
            End of section
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSToken.KeyWord">
            <summary>
            Keyword definition
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSToken.ParUndefined">
            <summary>
            Undefined/empty/NULL parameter value
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSToken.ParBoolTrue">
            <summary>
            True parameter value
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSToken.ParBoolFalse">
            <summary>
            False parameter value
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSToken.ParNumber">
            <summary>
            Number/integer parameter value
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSToken.ParFloat">
            <summary>
            Floating point Number (float/double) parameter value
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSToken.ParString">
            <summary>
            String parameter value
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSToken.ParClob">
            <summary>
            Character Large Object parameter value, a special kind of string
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSToken.ParFilename">
            <summary>
            File name parameter value
            </summary>
        </member>
        <member name="T:DHI.PFS.PFSTokenReader">
             <summary>
             Class for reading content of a PFS file. 
             It reads the PFS file token-by-token, when calling <see cref="M:DHI.PFS.PFSTokenReader.NextToken"/>.
             If data is associated with the token, these data can be retrieved using
             <see cref="M:DHI.PFS.PFSTokenReader.GetTokenString"/>.
             </summary>
             <example>
             Example of use:
             <code>
               PfsReader reader = new PfsReader(filename);
            
               int tokenCount = 0;
               PFSToken pfstNextToken;
               while ((pfstNextToken = reader.NextToken()) != PFSToken.PfsEOF)
               {
                 if (pfstNextToken == PFSToken.KeyWord &amp;&amp;
                     reader.GetTokenString() == "key3")
                 {
                   // Do something with keyword
                 }
                 tokenCount++;
               }
             
               reader.Dispose();
             </code>
             </example>
        </member>
        <member name="M:DHI.PFS.PFSTokenReader.#ctor(System.String)">
            <summary>
            Create a reader, opening the file specified.
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSTokenReader.Finalize">
            <summary>
            Dispose unmanaged ressources
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSTokenReader.Dispose">
            <inheritdoc />
        </member>
        <member name="M:DHI.PFS.PFSTokenReader.Close">
            <summary>
            Close Pfs file. 
            <para>
            Any use of the <see cref="T:DHI.PFS.PFSTokenReader"/> after call to close will
            throw an exception.
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSTokenReader.NextToken">
            <summary>
            Returns the next token in the PFS file
            </summary>
            <exception cref="T:DHI.PFS.PFSException">
            Thrown in case of an error when reading the file. Errors are usually related 
            to incorrectly formatted PFS files.
            </exception>
        </member>
        <member name="M:DHI.PFS.PFSTokenReader.GetTokenString">
            <summary>
            Get the string related to the current token.
            <para>
            Not all token types have data related to it. Only the 
            following tokens have data:
            <list type="bullet">
            <item><see cref="F:DHI.PFS.PFSToken.Section"/>: Name of section</item>
            <item><see cref="F:DHI.PFS.PFSToken.KeyWord"/>: Name of keyword</item>
            <item><see cref="F:DHI.PFS.PFSToken.ParFilename"/>: Parameter file name string</item>
            <item><see cref="F:DHI.PFS.PFSToken.ParNumber"/>: Parameter number as a string</item>
            <item><see cref="F:DHI.PFS.PFSToken.ParString"/>: Parameter string value</item>
            </list>
            </para>
            </summary>
            <returns></returns>
        </member>
        <member name="T:DHI.PFS.PFSErrorCode">
            <summary>
            Error codes from PFS system
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSErrorCode.pfs_OK">
            <summary>
            pfs_OK = 0
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSErrorCode.pfs_ERR_START">
            <summary>
            pfs_ERR_START = 1000
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSErrorCode.pfs_ERR_FILE_OPEN">
            <summary>
            pfs_ERR_FILE_OPEN = 1001
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSErrorCode.pfs_ERR_FILE_INIT">
            <summary>
            pfs_ERR_FILE_INIT = 1002
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSErrorCode.pfs_ERR_PARSE">
            <summary>
            pfs_ERR_PARSE = 1003
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSErrorCode.pfs_ERR_PARSER_INIT">
            <summary>
            pfs_ERR_PARSER_INIT = 1004
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSErrorCode.pfs_ERR_HANDLE">
            <summary>
            pfs_ERR_HANDLE = 1005
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSErrorCode.pfs_ERR_NODE">
            <summary>
            pfs_ERR_NODE = 1006
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSErrorCode.pfs_ERR_NAMENODE">
            <summary>
            pfs_ERR_NAMENODE = 1007
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSErrorCode.pfs_ERR_KEYWORD">
            <summary>
            pfs_ERR_KEYWORD = 1008
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSErrorCode.pfs_ERR_SECTION">
            <summary>
            pfs_ERR_SECTION = 1009
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSErrorCode.pfs_ERR_INVALIDINDEX">
            <summary>
            pfs_ERR_INVALIDINDEX = 1010
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSErrorCode.pfs_ERR_TARGETLIST">
            <summary>
            pfs_ERR_TARGETLIST = 1011
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSErrorCode.pfs_ERR_PARAMETER">
            <summary>
            pfs_ERR_PARAMETER = 1012
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSErrorCode.pfs_ERR_INDEPENDENTNODE">
            <summary>
            pfs_ERR_INDEPENDENTNODE = 1013
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSErrorCode.pfs_ERR_INVALIDPARAMETERTYPE">
            <summary>
            pfs_ERR_INVALIDPARAMETERTYPE = 1014
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSErrorCode.pfs_ERR_CLOB">
            <summary>
            pfs_ERR_CLOB = 1015
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSErrorCode.pfs_ERR_PFSDATAADD">
            <summary>
            pfs_ERR_PFSDATAADD = 2000
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSErrorCode.pfs_ERR_CLOBDATAADD">
            <summary>
            pfs_ERR_CLOBDATAADD = 2001
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSErrorCode.pfs_ERR_CLOBDATAGET">
            <summary>
            pfs_ERR_CLOBDATAGET = 2002
            </summary>
        </member>
        <member name="T:DHI.PFS.pfsNodeCallback">
            <summary>
            Call back to use with pfsExplore.
            </summary>
            <param name="handle">A pfsHandle pointer</param>
        </member>
        <member name="T:DHI.PFS.PFSDllWrapper">
            <summary>
            Wrapper class for pfs2004.dll. 
            <para>
            When possible, use instead the <see cref="T:DHI.PFS.PFSFile"/>, since it 
            adds error checking and exceptions to the file handling.
            </para>
            </summary>
            <remarks>
            Copied from pfs C Library documentation:
            <para>
            The MIKE Zero Parameter File Standard (PFS) is intended for storage of a 
            wide range of data, which may be organized or unstructured. Many of those 
            data which do not naturally match the MIKE Zero Data File Standard (DFS) 
            may be stored in a PFS file. Typical applications of PFS files are for 
            storing analysis definition parameters, or for saving internal state 
            parameters between two executions of an application.
             
            The structure of the PFS files has been designed with emphasis on robustness 
            and possibilities for a wide extent of automatic data validation. Even if 
            data may easily be exchanged between applications using simple ad hoc file 
            formats, the parameter file concept may be a way to avoid misunderstandings 
            and ease debugging of file based data exchange.
             
            The format of a parameter file is defined by a formal syntax which describes 
            how data must be written. Even if the syntax puts limitations on the use of 
            parameter files, it provides possibilities for strictly checking the contents 
            of files and automatic error reporting, with the intension of moving the 
            responsibility for many trivial data validation tasks from the application 
            programmer to the parameter file system.
             
            The application programmer accesses a parameter file through a programming 
            interface, and all read/write operations with associated data decoding and 
            encoding are handled by the parameter file system, not by the programmer.
             
            The PFS covers components with different levels of specialization and different 
            target groups. The PFS may be transparently integrated into an application 
            without the end-user's knowledge, and for the application programmer, not all 
            components must be mastered.
             
            The most general concepts are
             
             * parameter text files used for storing actual data
             * the syntax which describes the format for storing data in text files
             
            The application programmer will encounter
            
             * a programming interface used to write to and read from parameter files
             * parameter definition text files defining the data requirement for different applications
             * runtime instances of parameter files and parameter definitions
             * (application dependant validation functions)
             
            For a first introduction to the PFS it is adequate to think about a parameter 
            file as a text file written to conform with some loosely defined convention, 
            the details of which is initially of minor importance.
            
            The PFS has no user dialogs. The external interfaces are the application 
            programming interface, and the actual PFS files. The MIKE Zero Message 
            System is used for error reporting, unless silent version is called.
             
            The PFS programming interface is distributed in a Windows DLL and it may 
            be accessed from any programming language supporting the Windows API.
            </para>
            </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetVersion">
            <summary>
            Return a text string containing the date and time when the current software version was built. 
            </summary>    
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetDLLid">
            <summary>
            Return a text string containing the path of the DLL containing the current software version.
            </summary>    
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsLoadFile(System.String,System.Boolean)">
            <summary>
            Open an existing parameter file and create an internal data structure for further processing. 
            </summary>
            <param name="fileName">File Name </param>
            <param name="quiet">defines if possible error messages should be issued automatically by pfsLoadFile or not</param>
            <returns>A PFSHandle pointer. A handle for subsequent reference to the data structure is returned in Hand. 
            If the file could not be opened, the value of Hand is NULL</returns>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsCreate">
            <summary>
            Create an empty parameter structure to be used for writing a parameter file, or for creating a parameter definition. 
            </summary>
            <returns>A PfsHandle pointer. The pfsHandle returned must be used in subsequent calls to write interface functions or parameter definition functions</returns>
            <remarks>
            The pfsHandle returned must be used in subsequent calls to write interface functions or parameter definition functions. 
            </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsWrite(System.IntPtr,System.String)">
            <summary>
            Write the contents of a parameter file object using the parameter file syntax
            </summary>
            <param name="handle">A PfsFile handle</param>
            <param name="fileName">File Name</param>
            <remarks>
            This function is used to write any parameter file object, ie those created by pfsCreate, 
            and those created by loading an existing file using pfsLoadFile. Files written by pfsWrite may be read by pfsLoadFile. 
            </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAppend(System.IntPtr,System.String)">
            <summary>
            Append the contents of a parameter file object to an existing parameter file using the parameter file syntax. 
            </summary>
            <param name="handle">A pfsFile handle. Handle to parameter file object</param>
            <param name="fileName">File name to append to</param>
            <remarks>
            This function is similar to pfsWrite, except that the contents of the actual parameter
            object is appended to an existing file. If the specified file does not exist, the behaviour is equivalent to that of pfsWrite. 
            </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsClose(System.IntPtr@)">
            <summary>
            Terminate the access to a parameter file data structure and free the associated internal storage. 
            </summary>
            <param name="handle">A pfs File handle. Handle to terminate</param>
            <remarks>
            If Hand cannot be identified as a valid handle, nothing is done. After normal processing, the value NULL is returned in Hand. 
            </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsCopy(System.IntPtr,System.IntPtr)">
            <summary>
            Copy a sub-tree of a parameter object to a node of a parameter object. 
            </summary>
            <param name="src">A pfsNode pointer, source sub tree. </param>
            <param name="dst">A pfsNode pointer, destination sub tree.</param>
            <remarks>
            With two pfsNodes given, the sub-tree referenced by Src is copied to the position referenced by Dst. Src and Dst must both refer to sections, or both to keywords. Parameters may not be explicitly copied. During the copy process, the sub-tree originally connected to Dst is deleted, and the sub-tree referenced by Src remains unaffected. Src and Dst may belong to different pfsHandles. 
            </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsInsert(System.IntPtr,System.IntPtr,System.Boolean)">
            <summary>
             Insert parameter object into a src
            </summary>
            <param name="src">A pfsNode pointer, source sub tree</param>
            <param name="rel">A pfsNode pointer, where to insert source to (before or after)</param>
            <param name="before">Boolean specifying whether to insert src tree before or after rel</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsPeekErrorGlb">
            <summary>
            Inspect the current value of the global error code without affecting it. 
            </summary>
            <returns>A return value of pfs_OK indicates no error. Other numeric error codes are implemented as constants.</returns>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetErrorGlb">
            <summary>
            Extract and reset the global error code 
            </summary>
            <remarks>
            A return value of pfs_OK indicates no error. Other numeric error codes are implemented as constants. The internal global error status is assigned the value of pfs_OK. 
            pfs_OK				   0	Success
            pfs_ERR_START			1000	Unused
            pfs_ERR_FILE_OPEN		1001	Can't open input file
            pfs_ERR_FILE_INIT		1002	Can't initialize input stream
            pfs_ERR_PARSE			1003	Error during parsing
            pfs_ERR_PARSER_INIT		1004	Can't initialize parser
            pfs_ERR_HANDLE			1005	Bad handle passed to function
            pfs_ERR_NODE			1006	Bad node passed to function 
            etc.  (reference to definition of PFSErrorCode and method pfsErrorCodeToErrorMessage)
            </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetSyntaxErr(System.IntPtr,System.Int32@,System.Int32@,System.String@)">
            <summary>
            Return the position in the input file where a parameter file syntax error was detected with an associated error message. 
            </summary>
            <param name="handle">A pfsHandle</param>
            <param name="row">The error was detected near position Col in line Row</param>
            <param name="col">The error was detected near position Col in line Row</param>
            <param name="text">Associated message</param>
            <remarks>
            When an error status of pfs_ERR_PARSE has been set by pfsLoadFile, additional diagnostics may be obtained from this function. 
            </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsEquivalent(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
             To indicate if the contents of two parameter objects are equivalent.
            </summary>
            <param name="template">A pfsNode pointer, template- parameter to be compared</param>
            <param name="candidate">A pfsNode pointer, candidate- parameter to be compared</param>
            <param name="options">Indicate the level of strictness used in the comparison. It is currently inactive - a strict one-to-one criterion applies.</param>
            <remarks>
             The function is intended as a high level validation to compare a parameter
             file (the candidate) with the requirements of a specific application (the template).
            
             The Template and Candidate parameters represent parts of a parameters object
             to be compared, eg target vs target, or section vs section. Any subtree of a
             parameter structure may be used for comparison.
            </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsEquivalentExt(System.IntPtr,System.IntPtr,System.Int32,System.Boolean)">
            <summary>
            To indicate if the contents of two parameter objects are equivalent.
            </summary>
            <param name="template">a pfsNode pointer, Template- parameter to be compared</param>
            <param name="candidate">a pfsNode pointer, Candidate- parameter to be compared</param>
            <param name="options">Indicate the level of strictness used in the comparison. It is currently inactive - a strict one-to-one criterion applies.</param>
            <param name="quiet">defines if possible error messages should be issued automatically by pfsEquivalent or not.</param>
            <remarks>
             The function is intended as a high level validation to compare a parameter
             file (the candidate) with the requirements of a specific application (the template).
             
             The Template and Candidate parameters represent parts of a parameters object
             to be compared, eg target vs target, or section vs section. Any subtree of a
             parameter structure may be used for comparison.
            </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsNoTokens(System.IntPtr)">
            <summary>
            Return the number of terminal syntax elements processed 
            </summary>
            <param name="handle">A pfsHandle pointer</param>
            <remarks>
            This function is only relevant for debugging of internals. 
            </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsNoComments(System.IntPtr)">
            <summary>
            Return the number of comments skipped in the input parameter file 
            </summary>
            <param name="handle">A pfsHandle pointer</param>
            <remarks>This function is only relevant for debugging. </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsNoLines(System.IntPtr)">
            <summary>
            Return the number of lines read from the input parameter file 
            </summary>
            <param name="handle">A pfsHandle pointer</param>
            <remarks>This function is only relevant for debugging. </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsNoChars(System.IntPtr)">
            <summary>
            Return the number of characters read from the input parameter file.
            </summary>
            <param name="handle">A pfsHandle pointer</param>
            <remarks>This function is only relevant for debugging.</remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsExplore(System.IntPtr,DHI.PFS.pfsNodeCallback)">
            <summary>
            To provide an alternative to the lookup read interface. pfsExplore guides the application programmer through a PFS data structure and calls a user-defined function for each pfsNode encountered. The pfsNode is passed to the user-defined function for processing in the application context. With this approach, the application programmer needs not care about how to traverse the PFS data structure - this is done by pfsExplore - but instead pay attention to the position of the actual pfsNode in the structure. 
            </summary>
            <param name="handle">A pfsHandle pointer</param>
            <param name="callMeAt"></param>
            <remarks>See the application examples for a complete example (in pfsdll.w51). </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsDump(System.IntPtr,System.String)">
            <summary>
            Dump the contents of a parameter file object with detailed internal information into a text file.
            </summary>
            <param name="handle">A pfsNode/pfsHandle pointer</param>
            <param name="fileName">File name</param>
            <remarks>  
            The Handle function argument may be either a pfsHandle to refer to
            a complete parameter structure, or a pfsNode to refer to a sub-tree
            of the structure. pfsExplore is used to traverse the contents of
            the parameter object.
            </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetNoTargets(System.IntPtr)">
            <summary>
            Return the number of targets present in a parameter file. 
            </summary>
            <param name="handle">A pfsFile handle</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsTargetByNum(System.IntPtr,System.Int32)">
            <summary>
            Return a reference to the n'th target of a parameter file. 
            </summary>
            <param name="handle">A pfs File handle</param>
            <param name="targetNumber">Number of target, 1-based</param>
            <returns>A PfsNode pointer.</returns>
            <remarks>If the target does not exist, NULL is returned. </remarks>
            <example>
            <code>
            pfsHandle Hand = pfsLoadFile("somefile.pfv",FALSE);
            pfsNode Targ = pfsTargetByNum(Hand, 3);
            </code>
            </example>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsTargetByNameNum(System.IntPtr,System.String,System.Int32)">
            <summary>
            Return a reference to the n'th instance of a specific target name of a parameter file.
            </summary>
            <param name="handle">A pfsHandle pointer</param>
            <param name="targetName">Target name</param>
            <param name="targetNo1">Number of target with that name</param>
            <returns>A PfsNode pointer</returns>
            <remarks>If the target does not exist, NULL is returned. </remarks>
            <example>
            pfsHandle Hand = pfsLoadFile("somefile.pfv",FALSE);
            pfsNode Targ = pfsTargetByNameNum(Hand, "T0plot", 2);
            </example>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetNoSections(System.IntPtr)">
            <summary>
            Return the number of sections connected to the pfsNode passed as argument.
            </summary>
            <param name="node">A pfsNode pointer</param>
            <example>
             pfsHandle Hand = pfsLoadFile("somefile.pfv",FALSE);
             pfsNode Targ = pfsTargetByNum(Hand, 1);
             LONG sNum = pfsGetNoSections(Targ);
            </example>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsSectionByNum(System.IntPtr,System.Int32)">
            <summary>
            Return a reference to the n'th section of the pfsNode (target/section) passed as argument.
            </summary>
            <param name="node">A pfsNode pointer</param>
            <param name="sectionNo1"></param>
            <returns>A PfsNode pointer</returns>
            <remarks>If the section does not exist, NULL is returned. </remarks>
            <example>
             pfsHandle Hand = pfsLoadFile("somefile.pfv",FALSE);
             pfsNode Targ = pfsTargetByNum(Hand, 3);
             pfsNode section = pfsSectionByNum(Targ, 1);
            </example>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsSectionByNameNum(System.IntPtr,System.String,System.Int32)">
            <summary>
            Returns a reference to the n'th instance of a specific subsection name of the pfsNode (target/section) passed as argument.
            </summary>
            <param name="section">A pfsNode pointer</param>
            <param name="sectionName">Name of section.</param>
            <param name="sectionNum">Number of section with that name.</param>
            <returns>A PfsNode pointer. If the section does not exist, NULL is returned. </returns>
            <example> 
             pfsHandle Hand = pfsLoadFile("somefile.pfv",FALSE);
             pfsNode   Targ = pfsTargetByNameNum(Hand,"T0plot",3);
             pfsNode   section = pfsSectionByNameNum(Targ,"Axes",1);
            </example>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsFindSectionByHandle(System.IntPtr,System.String)">
             <summary>
             Returns the section specified in the sectionPath parameter
             </summary>
             <param name="node">a pfsNode pointer</param>
             <param name="sectionPath">the position of the section specified relative from the nPfs node</param>
             <remarks>
             The section path is specified in the form section1/section2/section3. A section
             name can be ".." which means the parent section to the current section.
            
             The section can include a sequence number in the form "name:no" - no gives
             the sequence number of section with the specified name. This is only relevant
             if more than one section at the same level have the same name.
             </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetNoKeywords(System.IntPtr)">
            <summary>
            Return the number of keywords connected to the pfsNode passed as argument
            </summary>
            <param name="node">A pfsNode pointer</param>
            <remarks>
             pfsHandle Hand = pfsLoadFile("somefile.pfv",FALSE);
             pfsNode   Targ = pfsTargetByNum(Hand,1);
             LONG      sNum = pfsGetNoKeywords(Targ);
            </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsKeywordByNum(System.IntPtr,System.Int32)">
            <summary>
            Return a reference to the n'th keyword of the pfsNode (target/section) passed as argument. 
            </summary>
            <param name="node">A pfsNode pointer</param>
            <param name="keywordNum">Number of keyword, 1-based</param>
            <returns>A pfsNode pointer. If the keyword does not exist, NULL is returned. </returns>
            <example>
              pfsHandle Hand = pfsLoadFile("somefile.pfv",FALSE);
              pfsNode   Targ = pfsTargetByNum(Hand,1);
              pfsNode   kNum = pfsGetKeywordByNum(Targ,3);
            </example>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsKeywordByNameNum(System.IntPtr,System.String,System.Int32)">
            <summary>
            Returns a reference to the n'th instance of a specific keyword name of the pfsNode (target/section) passed as argument.
            </summary>
            <param name="section">A pfsNode pointer</param>
            <param name="keywordName">Name of key word</param>
            <param name="keywordNum">Number of keyword with that name, 1-based.</param>
            <returns>A pfsNode Pointer. If the keyword does not exist, NULL is returned. </returns>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetNoParams(System.IntPtr)">
            <summary>
            Return the number of parameters connected to the pfsNode passed as argument. 
            </summary>
            <param name="node">A PfsNode</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsParamByNum(System.IntPtr,System.Int32)">
            <summary>
            Return a reference to the n'th parameter of the pfsNode (keyword) passed as argument. 
            </summary>
            <param name="node">A pfsNode pointer</param>
            <param name="paramNum">Number of parameter to get, 1-based</param>
            <returns>A pfsNode pointer.</returns>
            <remarks>
            The function returns a reference to a parameter value, not the value itself. The value must be extracted using the parameter value extraction function for the particular data type. Please note, that parameters may only be referenced by number. 
            </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsPutListParam(System.IntPtr,System.String,System.String,System.Int32[])">
            <summary>
             Write a list of parameters
            </summary>
            <param name="handle"></param>
            <param name="key"></param>
            <param name="argtypelist"></param>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetNoNodes(System.IntPtr)">
            <summary>
             Get number of nodes
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsNodeByNum(System.IntPtr,System.Int32)">
            <summary>
             Get node by number (1 based)
            </summary>
            <param name="node">Parent number to search in</param>
            <param name="nodeNum">Number of node to get (1 based)</param>
            <returns></returns>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsIsTarget(System.IntPtr)">
            <summary>
            Indicates if the pfsNode passed as argument refers to a target of a parameter structure. 
            </summary>
            <param name="node">A pfsNode pointer</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsIsKeyword(System.IntPtr)">
            <summary>
            Indicates if the pfsNode passed as argument refers to a keyword of a parameter structure. 
            </summary>
            <param name="node">A pfsNode pointer</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsIsParam(System.IntPtr)">
            <summary>
            Indicates if the pfsNode passed as argument refers to a parameter of a parameter structure. 
            </summary>
            <param name="node">A pfsNode pointer</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetName(System.IntPtr)">
            <summary>
            Return the name of the pfsNode (target/section or keyword) passed as argument. 
            </summary>
            <param name="node">A pfsNode pointer</param>   
            <remarks>
            The function returns the name of a target/section or a keyword as it appears in a parameter file. If pfsNode refers to a section definition written [Axis_definition], pfsGetName(Node) returns the string Axis_definition, and if pfsNode refers to a keyword definition written AxisLimits = 7, 9, 0.1 pfsGetName returns the string AxisLimits. 
            </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetNameGlb(System.IntPtr)">
            <summary>
            Return the global name of the pfsNode (target/section or keyword) passed as argument. 
            </summary>
            <param name="node">A pfsNode pointer</param>    
            <remarks>
            The global name is the concatenation of the node name and the section names on higher levels separated by periods, eg Target.A_sect.B_sect.C_keyw 
            </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetLevel(System.IntPtr)">
            <summary>
            Return the level in the parameter structure of the pfsNode passed as argument. 
            </summary>
            <param name="node">A pfsNode pointer</param>
            <remarks>
            Targets are at level 0, sections and keywords connected to targets are at level 1 etc. 
            </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetInstanceNo(System.IntPtr)">
            <summary>
            Return the instance number of the node (target/section or keyword) passed as argument. 
            </summary>
            <param name="node">A pfsNode pointer</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetNoInstances(System.IntPtr)">
            <summary>
            Return the number of instances of the pfsNode (target/section or keyword) passed as argument. 
            </summary>
            <param name="node">A pfsNode pointer</param>
            <remarks>
            Sections and keywords may be multiple defined. This function returns the number of times a target/section or keyword appears in the given context. 
            </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetSyntaxClass(System.IntPtr)">
            <summary>
            Return the syntax class of the node which is passed as argument. 
            </summary>
            <param name="node">A pfsNode pointer</param>
            <remarks>This function is only relevant for expert/debug use. It returns the internal syntax class of a token as identified by the PFS parser. </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetAnchorFilename(System.IntPtr)">
            <summary>
             Get the anchor filename from node
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsSetAnchorFilename(System.IntPtr,System.String)">
            <summary>
             Set anchor filename of node
            </summary>
            <param name="node"></param>
            <param name="filename"></param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsIsNumeric(System.IntPtr)">
            <summary>
            Indicates if the pfsNode passed as argument refers to a numeric parameter value. 
            
            A numeric value is etther an integer, a float, or a double. For the exact type the respecctive type information functions should be called. 
            </summary>
            <param name="node">A pfsNode pointer</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsIsInt(System.IntPtr)">
            <summary>
            Indicates if the pfsNode passed as argument refers to an integer parameter value. 
            </summary>
            <param name="node">A pfsNode pointer</param>
            <remarks>
            The integer values accepted are
             ?numeric values written without decimal point in the valid range
               for long (4 bytes) integers, which is [-2147483648, 2147483647]
             ?numeric values written in real notation, which may be represented
               by a long integer without loss of precision
            </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsIsFloat(System.IntPtr)">
            <summary>
            Indicates if the pfsNode passed as argument refers to a float (4-byte single precision floating point) parameter value. 
            </summary>
            <param name="node">a pfsNode pointer</param>
            <remarks>
            The float values accepted are numeric values in the valid range for single precision real values written in integer or real notation. The value of eg 10 may be considered a float, a double, and an integer. Values in integer notation outside the valid integer range but inside the valid float range are considered to be floats. 
            The valid range for float values depends on the hardware. For the IEEE 754 floating point format which is used on PCs, the maximum numeric value is 3.4E38, and the minimum numeric value is 3.4E-38 or 1.5E-45 depending on the compiler implementation. 
            NOTE: The ambiguity about the minimum numeric value may cause problems! 
            </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsIsDouble(System.IntPtr)">
            <summary>
            Indicates if the pfsNode passed as argument refers to a double (8-byte double precision floating point) parameter value. 
            </summary>
            <param name="node">A pfsNode pointer</param>
            <remarks>
            The double values accepted are numeric values in the valid range for double precision real values written in integer or real notation. Integer values outside the valid integer range or real values outside the valid float range are considered to be double values. 
            The valid range for double values depends on the hardware. For the IEEE 754 floating point format which is used on PCs, the maximum numeric value is 1.7E308, and the minimum numeric value is 1.7E-308, alternatively 5.0E-324. 
            NOTE: The ambiguity about the minimum numeric value may cause problems! 
            </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsIsString(System.IntPtr)">
            <summary>
            Indicates if the pfsNode passed as argument refers to a string value. 
            </summary>
            <param name="node">A pfsNode pointer</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsIsBool(System.IntPtr)">
            <summary>
            Indicates if the pfsNode passed as argument refers to a string value. 
            </summary>
            <param name="node">A pfsNode pointer</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsIsDefaultPar(System.IntPtr)">
            <summary>
            Indicates if the pfsNode passed as argument refers to a default parameter definition. 
            </summary>
            <param name="node">A pfsNode pointer</param>
            <remarks>
            The substitution of default parameters is transparent, so a parameter which is designated default is also designated one of the simple types. 
            </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsIsFilename(System.IntPtr)">
            <summary>
             Return true of the node is a filename
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetInt(System.IntPtr)">
            <summary>
            Return the integer value from the pfsNode (parameter) passed as argument. 
            </summary>
            <param name="node">A pfsNode pointer</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetFloat(System.IntPtr)">
            <summary>
            Return the float (4-byte single precision floating point) value from the pfsNode (parameter) passed as argument. 
            </summary>
            <param name="node">A pfsNode pointer</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetDouble(System.IntPtr)">
            <summary>
            Return the double (8-byte double precision floating point) value from the pfsNode (parameter) passed as argument. 
            </summary>
            <param name="node">A pfsNode pointer</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetString(System.IntPtr)">
            <summary>
            Return a string value of the pfsNode (parameter) passed as argument. 
            </summary>
            <param name="node">A pfsNode pointer</param>    
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetFilename(System.IntPtr)">
            <summary>
             Get the filename from the node
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetFilenameString(System.IntPtr)">
            <summary>
             Get the filename from the node
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetBool(System.IntPtr)">
            <summary>
            Return the Boolean value from the pfsNode (parameter) passed as argument. 
            </summary>
            <param name="node">A pfsNode pointer</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetResultFilename(System.IntPtr)">
            <summary>
             Get the filename from the node
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetResultFilenamePath(System.IntPtr)">
            <summary>
            Return the result folder path for the pfs file. The node can be any PFS node
            in the pfs tree.
            </summary>
            <param name="node">Any pfsNode pointer</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetResultFolderPath(System.IntPtr)">
            <summary>
            Return the result folder path for the pfs file. The node can be any PFS node
            in the pfs tree.
            </summary>
            <param name="node">Any pfsNode pointer</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetProjectResultRoot(System.IntPtr)">
            <summary>
            Get the project result root folder
            </summary>
            <param name="node">Any pfsNode pointer within the PFS tree</param>
            <returns>Result root folder</returns>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsSetProjectResultRoot(System.IntPtr,System.String)">
            <summary>
            Set the project result root folder
            </summary>
            <param name="handle">Any pfsNode pointer within the PFS tree</param>
            <param name="resultRoot">Result root folder</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetCustomResultFolder(System.IntPtr,System.Int32@)">
            <summary>
            Returns the custom result folder.
            </summary>
            <param name="node">A pfsNode pointer within the PFS tree</param>
            <param name="useCustom">Boolean output flag that returns whether the "use custom results" flag has been set.</param>
            <returns>Custom result folder string</returns>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsFindDefault(System.IntPtr)">
            <summary>
            Return a reference to a non-default parameter node with a default value for the default parameter node which is passed as argument. 
            </summary>
            <param name="node">A pfsNode pointer</param>
            <remarks>
            pfsExplore does not perform automatic default parameter substitution, so if the user-defined pfsNodeCallback function encounters a pfsNode which pfsIsDefaultPar(pfsNode) evaluates as true, pfsFindDefault(pfsNode) may return a pfsNode reference to the default parameter, or NULL if no default may be found. 
            </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddTarget(System.IntPtr,System.String)">
            <summary>
            Add a new target (top-level section) to a parameter file object. 
            </summary>
            <param name="handle">A pfsHandle pointer.</param>
            <param name="targetName">Name of target to add.</param>
            <remarks>
             This function is always the first function to be called after pfsCreate,
             and the target definition must be terminated by a pfsEndSection.
             
             Restrictions:  Possible previous targets must be have been properly
             terminated by calls to pfsEndSection. 
            </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddTargetS(System.IntPtr,System.String)">
            <summary>
            Add a new target (top-level section) to a parameter file object. 
            <para>
            Silent version that throws exception on failure
            </para>
            </summary>
            <param name="handle">A pfsHandle pointer.</param>
            <param name="targetName">Name of target to add.</param>
            <remarks>
             This function is always the first function to be called after pfsCreate,
             and the target definition must be terminated by a pfsEndSection.
             
             Restrictions:  Possible previous targets must be have been properly
             terminated by calls to pfsEndSection. 
            </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddSection(System.IntPtr,System.String)">
            <summary>
            Start a new section within the scope of a target. 
            </summary>
            <param name="handle">A pfsHandle pointer</param>
            <param name="sectionName">Name of section to add.</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddSectionS(System.IntPtr,System.String)">
            <summary>
            Start a new section within the scope of a target. 
            <para>
            Silent version that throws exception on failure
            </para>
            </summary>
            <param name="handle">A pfsHandle pointer</param>
            <param name="sectionName">Name of section to add.</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsEndSection(System.IntPtr)">
             <summary>
             Terminate a target or a section. 
             </summary>
             <param name="handle">A pfsHandle pointer.</param>
             <remarks>
               In a few situations pfsEndSection may be legally omitted, but it is
              recommended never to use this property.
            
              Restrictions:  Each pfsEndSection must match a pfsAddTarget or a pfsAddSection. 
             </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsEndSectionS(System.IntPtr)">
             <summary>
             Terminate a target or a section. 
             <para>
             Silent version that throws exception on failure
             </para>
             </summary>
             <param name="handle">A pfsHandle pointer.</param>
             <remarks>
               In a few situations pfsEndSection may be legally omitted, but it is
              recommended never to use this property.
            
              Restrictions:  Each pfsEndSection must match a pfsAddTarget or a pfsAddSection. 
             </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddKeyword(System.IntPtr,System.String)">
             <summary>
             Define a keyword, ie the start of a parameter list, within the scope of a target. 
             </summary>
             <param name="handle">A pfsHandle pointer</param>
             <param name="keywordName">Name of keyword to add.</param>
             <remarks>
               This function is used to define the start of a list of parameters.
              It has no counterpart, ie the usage is different from that of pfsAddSection,
              which requires a terminating pfsEndSection.
            
              Restrictions:  This function must be called within the scope of a target. 
             </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddKeywordS(System.IntPtr,System.String)">
             <summary>
             Define a keyword, ie the start of a parameter list, within the scope of a target. 
             <para>
             Silent version that throws exception on failure
             </para>
             </summary>
             <param name="handle">A pfsHandle pointer</param>
             <param name="keywordName">Name of keyword to add.</param>
             <remarks>
               This function is used to define the start of a list of parameters.
              It has no counterpart, ie the usage is different from that of pfsAddSection,
              which requires a terminating pfsEndSection.
            
              Restrictions:  This function must be called within the scope of a target. 
             </remarks>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddInt(System.IntPtr,System.Int32)">
            <summary>
            Write a four-byte signed integer.
            
            Restrictions: The function is only valid within the scope of a keyword 
            </summary>
            <param name="handle">A pfsHandle pointer</param>
            <param name="val"></param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddIntS(System.IntPtr,System.Int32)">
            <summary>
            Write a four-byte signed integer.
            <para>
            Silent version that throws exception on failure
            </para>
            <para>
              Restrictions:  The function is only valid within the scope of a keyword.  
            </para>
            </summary>
            <param name="handle">A pfsHandle pointer</param>
            <param name="val"></param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddFloat(System.IntPtr,System.Single)">
            <summary>
            Write a single precision floating-point (real) value.
            
            The output format is some 'default' format. Check if it may cause loss of precision.
            
              Restrictions:  The function is only valid within the scope of a keyword.  
            </summary>
            <param name="handle">A pfsHandle pointer</param>
            <param name="val"></param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddFloatS(System.IntPtr,System.Single)">
            <summary>
            Write a single precision floating-point (real) value.
            
            The output format is some 'default' format. Check if it may cause loss of precision.
            <para>
            Silent version that throws exception on failure
            </para>
            <para>
              Restrictions:  The function is only valid within the scope of a keyword.  
            </para>
            </summary>
            <param name="handle">A pfsHandle pointer</param>
            <param name="val"></param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddString(System.IntPtr,System.String)">
            <summary>
            Write a null-terminated character string. 
            
            Restrictions: The function is only valid within the scope of a keyword. In a Pascal program, the use of null-terminated strings must be enforced using a compiler option. 
            </summary>
            <param name="handle">A pfsHandle pointer</param>
            <param name="val">String value</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddStringS(System.IntPtr,System.String)">
            <summary>
            Write a null-terminated character string. 
            <para>
            Silent version that throws exception on failure
            </para>
            <para>
            Restrictions: The function is only valid within the scope of a keyword. In a Pascal program, the use of null-terminated strings must be enforced using a compiler option. 
            </para>
            </summary>
            <param name="handle">A pfsHandle pointer</param>
            <param name="val">String value</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddFilename(System.IntPtr,System.String)">
            <summary>
             Write a null-termindated character string to keyword
             <para>
             Restrictions: The function is only valid within the scope of a keyword. In a Pascal program, the use of null-terminated strings must be enforced using a compiler option. 
             </para>
            </summary>
            <param name="handle">A pfs parameter handle</param>
            <param name="val">File name string</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddFilenameS(System.IntPtr,System.String)">
            <summary>
             Write a null-termindated character string to keyword
             <para>
             Silent version that throws exception on failure
             </para>
             <para>
             Restrictions: The function is only valid within the scope of a keyword. In a Pascal program, the use of null-terminated strings must be enforced using a compiler option. 
             </para>
            </summary>
            <param name="handle">A pfs parameter handle</param>
            <param name="val">File name string</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddBool(System.IntPtr,System.Boolean)">
             <summary>
             Write a Boolean value 
             
               The Boolean value is written true or false.
            
              Restrictions:  The function is only valid within the scope of a keyword. 
             </summary>
             <param name="handle">A pfsHandle pointer</param>
             <param name="val"></param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddBoolS(System.IntPtr,System.Boolean)">
            <summary>
            Write a Boolean value to keyword
            <para>
            Silent version that throws exception on failure
            </para>
            <para>
              Restrictions:  The function is only valid within the scope of a keyword.  
            </para>
            </summary>
            <param name="handle">A pfsHandle pointer</param>
            <param name="val">boolean value</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddDouble(System.IntPtr,System.Double)">
            <summary>
            Purpose Write a double precision floating-point (real) value. 
            
            The output format is some 'default' format. Check if it may cause loss of precision.
            
              Restrictions:  The function is only valid within the scope of a keyword. 
            </summary>
            <param name="handle">A pfsHandle pointer</param>
            <param name="val"></param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddDoubleS(System.IntPtr,System.Double)">
            <summary>
            Purpose Write a double precision floating-point (real) value. 
            <para>
            The output format is some 'default' format. Check if it may cause loss of precision.
            </para>
            <para>
            Silent version that throws exception on failure
            </para>
            <para>
              Restrictions:  The function is only valid within the scope of a keyword. 
            </para>
            </summary>
            <param name="handle">A pfsHandle pointer</param>
            <param name="val"></param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddIntRef(System.IntPtr,System.Int32@)">
            <summary>
            Save the address of a four-byte signed integer variable to be written. 
            
            Restrictions: The function is only valid within the scope of a keyword. The value written is the contents of the associated variable when pfsWrite is called. 
            </summary>
            <param name="handle">A pfsHandle pointer</param>
            <param name="val"></param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddFloatRef(System.IntPtr,System.Single@)">
            <summary>
            Save the address of a single precision floating-point (real) variable to be written. 
            
            Restrictions: The function is only valid within the scope of a keyword. The value written is the contents of the associated variable when pfsWrite is called. 
            </summary>
            <param name="handle">A pfsHandle pointer</param>
            <param name="val"></param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddDoubleRef(System.IntPtr,System.Double@)">
            <summary>
            Save the address of a double precision floating-point (real) variable to be written. 
            
            Restrictions: The function is only valid within the scope of a keyword. The value written is the contents of the associated variable when pfsWrite is called. 
            </summary>
            <param name="handle">A pfsHandle pointer</param>
            <param name="val"></param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddBoolRef(System.IntPtr,System.Boolean@)">
            <summary>
            Save the address of a Boolean variable to be written. 
            
            Restrictions: The function is only valid within the scope of a keyword. The value written is the contents of the associated variable when pfsWrite is called. 
            </summary>
            <param name="handle">A pfsHandle pointer</param>
            <param name="val"></param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddStringRef(System.IntPtr,System.String@)">
            <summary>
            Save the address of a null-terminated character string variable to be written. 
            
            Restrictions: The function is only valid within the scope of a keyword. The value written is the contents of the associated variable when pfsWrite is called. 
            </summary>
            <param name="handle">Aa pfsHandle pointer</param>
            <param name="val"></param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddSectionDef(System.IntPtr,System.String,System.Boolean,System.Boolean)">
             <summary>
             Define the start of a new section and its attributes within the scope of a target. 
             
              The section definition must be terminated by a pfsEndSection.
            
              Restrictions:  The pfsAddSectionDef must be called within the scope of a target. 
             </summary>
             <param name="handle">A pfsHandle pointer</param>
             <param name="sectionName">Name of section</param>
             <param name="multi">Indicates if multiple instances of the section are allowed (contrary to a unique section). </param>
             <param name="mandatory">Indicates if the section is mandatory (contrary to optional).</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddKeywordDef(System.IntPtr,System.String,System.String,System.Boolean,System.Boolean,System.Boolean)">
             <summary>
             Define the start of a new keyword, ie the start of a parameter list, and its attributes within the scope of a target. 
             
             This function is used to define the start of a list of parameters.
              It has no counterpart, ie the usage is different from that of
              pfsAddSectionDef, which requires a terminating pfsEndSection.
            
              Restrictions:  This function must be called within the scope of a target.
             </summary>
             <param name="handle">A pfsHandle pointer</param>
             <param name="keywordName">Nakme of Keyword</param>
             <param name="parTypes"></param>
             <param name="multi">Indicates if multiple instances of the section are allowed (contrary to a unique section). </param>
             <param name="mandatory">Indicates if the section is mandatory (contrary to optional). </param>
             <param name="reptLast"></param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddIntDef(System.IntPtr)">
            <summary>
            Request the presence of a four-byte signed integer value.
            
            Restrictions	The function is only valid within the scope of a keyword.
            </summary>
            <param name="handle">A pfsHandle pointer</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddFloatDef(System.IntPtr)">
            <summary>
            Request the presence of a single precision floating-point (real) value.
            
             Restrictions:  The function is only valid within the scope of a keyword.
            </summary>
            <param name="handle">A pfsHandle pointer</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddDoubleDef(System.IntPtr)">
            <summary>
            Request the presence of a double precision floating-point (real) value
            
            Restrictions:  The function is only valid within the scope of a keyword
            </summary>
            <param name="handle">A pfsHandle pointer</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddStringDef(System.IntPtr)">
            <summary>
            Request the presence of a character string value.
            
            Restrictions:  The function is only valid within the scope of a keyword.
            </summary>
            <param name="handle">A pfsHandle pointer</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddFilenameDef(System.IntPtr)">
            <summary>
            Request the presence of a character string value.
            
            Restrictions:  The function is only valid within the scope of a keyword.
            </summary>
            <param name="handle">A pfsHandle pointer</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddBoolDef(System.IntPtr)">
            <summary>
            Request the presence of a Boolean value.
            
            Restrictions:  The function is only valid within the scope of a keyword
            </summary>
            <param name="handle">A pfsHandle pointer</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddDateDef(System.IntPtr)">
            <summary>
             Add date definition
            </summary>
            <param name="handle"></param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddTimeDef(System.IntPtr)">
            <summary>
             Add time definition
            </summary>
            <param name="handle"></param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsErrorCodeToErrorMessage(DHI.PFS.PFSErrorCode)">
            <summary>
            Return a textual error message for a given <see cref="T:DHI.PFS.PFSErrorCode"/>
            reference to an alternative and newer method "pfsGetErrorMessageFromErrorCode"
            </summary>
            <param name="pfsErrorCode"></param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddClob(System.IntPtr)">
            <summary>
            Add a CLOB param to current keyword. 
            <para>
              Restrictions:  The function is only valid within the scope of a keyword.  
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddClobS(System.IntPtr)">
            <summary>
            Add a CLOB param to current keyword. 
            <para>
            Silent version that throws exception on failure
            </para>
            <para>
              Restrictions:  The function is only valid within the scope of a keyword.  
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddClobBool(System.IntPtr,System.Boolean)">
            <summary>
            Write a Boolean to current CLOB.
            <para>
              Restrictions:  The function is only valid within the scope of a Clob.  
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddClobBoolS(System.IntPtr,System.Boolean)">
            <summary>
            Write a Boolean to current CLOB.
            <para>
            Silent version that throws exception on failure
            </para>
            <para>
              Restrictions:  The function is only valid within the scope of a Clob.  
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddClobInt(System.IntPtr,System.Int32)">
            <summary>
            Write a Integer to current CLOB
            <para>
              Restrictions:  The function is only valid within the scope of a Clob.  
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddClobIntS(System.IntPtr,System.Int32)">
            <summary>
            Write a Integer to current CLOB
            <para>
            Silent version that throws exception on failure
            </para>
            <para>
              Restrictions:  The function is only valid within the scope of a Clob.  
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddClobFloat(System.IntPtr,System.Single)">
            <summary>
            Write a Float to current CLOB
            <para>
              Restrictions:  The function is only valid within the scope of a Clob.  
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddClobFloatS(System.IntPtr,System.Single)">
            <summary>
            Write a Float to current CLOB
            <para>
            Silent version that throws exception on failure
            </para>
            <para>
              Restrictions:  The function is only valid within the scope of a Clob.  
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddClobDouble(System.IntPtr,System.Double)">
            <summary>
            Write a Double to current CLOB
            <para>
              Restrictions:  The function is only valid within the scope of a Clob.  
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddClobDoubleS(System.IntPtr,System.Double)">
            <summary>
            Write a Double to current CLOB
            <para>
            Silent version that throws exception on failure
            </para>
            <para>
              Restrictions:  The function is only valid within the scope of a Clob.  
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddClobString(System.IntPtr,System.String)">
            <summary>
            Write a String to current CLOB
            <para>
              Restrictions:  The function is only valid within the scope of a Clob.  
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddClobStringS(System.IntPtr,System.String)">
            <summary>
            Write a String to current CLOB
            <para>
            Silent version that throws exception on failure
            </para>
            <para>
              Restrictions:  The function is only valid within the scope of a Clob.  
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddClobFilename(System.IntPtr,System.String)">
            <summary>
            Write a Filename to current CLOB
            <para>
              Restrictions:  The function is only valid within the scope of a Clob.  
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddClobFilenameS(System.IntPtr,System.String)">
            <summary>
            Write a Filename to current CLOB
            <para>
            Silent version that throws exception on failure
            </para>
            <para>
              Restrictions:  The function is only valid within the scope of a Clob.  
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsIsClob(System.IntPtr)">
            <summary>
            Tell if a Node is a CLOB
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetClobBool(System.IntPtr)">
            <summary>
            Extract a Boolean from current CLOB
            </summary>
            <param name="node">CLOB node</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetClobBoolS(System.IntPtr)">
            <summary>
            Extract a Boolean from current CLOB
            </summary>
            <param name="node">CLOB node</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetClobInt(System.IntPtr)">
            <summary>
            Extract a Integer from current CLOB
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetClobIntS(System.IntPtr)">
            <summary>
            Extract an integer from current CLOB
            </summary>
            <param name="node">CLOB node</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetClobFloat(System.IntPtr)">
            <summary>
            Extract a Float from current CLOB
            </summary>
            <param name="node">CLOB node</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetClobFloatS(System.IntPtr)">
            <summary>
            Extract a Float from current CLOB
            </summary>
            <param name="node">CLOB node</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetClobDouble(System.IntPtr)">
            <summary>
            Extract a Double from current CLOB
            </summary>
            <param name="node">CLOB node</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetClobDoubleS(System.IntPtr)">
            <summary>
            Extract a Double from current CLOB
            </summary>
            <param name="node">CLOB node</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetClobString(System.IntPtr)">
            <summary>
            Extract a String from current CLOB
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetClobStringS(System.IntPtr)">
            <summary>
            Extract a String from current CLOB
            </summary>
            <param name="node">CLOB node</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetClobFilename(System.IntPtr)">
            <summary>
            Extract a Filename from current CLOB
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetClobFilenameS(System.IntPtr)">
            <summary>
            Extract a Filename from current CLOB
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper._pfsGetClobString(System.IntPtr)">
            <summary>
            Extract a String from current CLOB
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper._pfsGetClobFilename(System.IntPtr)">
            <summary>
            Extract a Filename from current CLOB
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetClobItem(System.IntPtr)">
            <summary>
            Get the next Clob parameter as a PFSParameter handle,
            where you can query it for the type of parameter data.
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetClobItemS(System.IntPtr)">
            <summary>
            Get the next Clob parameter as a PFSParameter handle,
            where you can query it for the type of parameter data.
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsIsClobEnd(System.IntPtr)">
            <summary>
            Returns true of the Clob has no more parameters
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsIsClobEndS(System.IntPtr)">
            <summary>
            Returns true of the Clob has no more parameters
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsClobReset(System.IntPtr,System.Boolean)">
            <summary>
            Reset reading of parameters from Clob
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsClobResetS(System.IntPtr,System.Boolean)">
            <summary>
            Reset reading of parameters from Clob
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetRoot(System.IntPtr)">
            <summary>
            Get root of PFS tree
            </summary>
            <param name="pfsHandle">Any PFS node handle in the PFS tree</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfseInsertNewSection(System.IntPtr,System.String,System.Int32)">
            <summary>
            Insert new section into PFS section, return handle to new section
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfseInsertNewKeyword(System.IntPtr,System.String,System.Int32)">
            <summary>
            Insert new keyword into PFS section, return handle to new section
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfseInsertNewParameterBool(System.IntPtr,System.Boolean,System.Int32)">
            <summary>
            Insert new parameter into PFS keyword, return handle to new parameter
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfseInsertNewParameterInt(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Insert new parameter into PFS keyword, return handle to new parameter
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfseInsertNewParameterDouble(System.IntPtr,System.Double,System.Int32)">
            <summary>
            Insert new parameter into PFS keyword, return handle to new parameter
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfseInsertNewParameterString(System.IntPtr,System.String,System.Int32)">
            <summary>
            Insert new parameter into PFS keyword, return handle to new parameter
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfseInsertNewParameterFileName(System.IntPtr,System.String,System.Int32)">
            <summary>
            Insert new parameter into PFS keyword, return handle to new parameter
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfseInsertNewParameterClob(System.IntPtr,System.Int32)">
            <summary>
            Insert new parameter into PFS keyword, return handle to new parameter
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfseInsertNewParameterUndefined(System.IntPtr,System.Int32)">
            <summary>
            Insert new parameter into PFS keyword, return handle to new parameter
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsIsUndefinedPar(System.IntPtr)">
            <summary>
            Indicates if the pfsNode passed as argument refers to a string value. 
            </summary>
            <param name="node">A pfsNode pointer</param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddUndefinedPar(System.IntPtr)">
            <summary>
            Add a undefined param to current keyword. 
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsAddUndefinedParS(System.IntPtr)">
            <summary>
            Add a undefined param to current keyword. 
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetErrorMessageFromErrorCode(System.Int32)">
            <summary>
            this method is similar with method pfsErrorCodeToErrorMessage
            but this method is call the interpreter from pfs2004 dll 
            and this method support more error code
            </summary>
            <param name="errorCode"></param>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetErrorFromPfsData(System.IntPtr)">
            <summary>
            Extract error string
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSDllWrapper.pfsGetErrorFromPfsClob(System.IntPtr)">
            <summary>
            Extract error string
            </summary>
        </member>
        <member name="T:DHI.PFS.PFSSection">
            <summary>
            A PFSSection object represents a section in a PFS file.
            <para>
            A PFSSection can have other sections and keywords inside it.
            </para>
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSSection._sect">
            <summary> Handle to section (Unmanaged pointer) </summary>
        </member>
        <member name="F:DHI.PFS.PFSSection._keywordsNoMap">
            <summary>
            Buffer of keywordsNo (number of keywords) for all existing keyword names.
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSSection._sectionsNoMap">
            <summary>
            Buffer of sectionsNo (number of sections) for all existing section names.
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSSection.#ctor(System.IntPtr)">
            <summary>
            Initialize a new PFSSection with the given pfsNode pointer.
            </summary>
        </member>
        <member name="F:DHI.PFS.PFSSection._name">
            <summary>
            Buffer of name of section
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSSection.GetSectionsCount">
            <summary>
            Get the number of sub-sections within this section
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSSection.GetSection(System.Int32)">
            <summary>
            Get the section at the specified position.
            <para>
            To get the first section, use
            <code>
            section.GetSection(1);
            </code>
            </para>
            </summary>
            <param name="sectionNumber">Number of section. 1-based.</param>
        </member>
        <member name="M:DHI.PFS.PFSSection.GetSection(System.String,System.Int32)">
            <summary>
            Get the n'ths section instance with the specified name
            <para>
            To get the first section of a certain name, use
            <code>
            section.GetSection("sectionName", 1);
            </code>
            </para>
            </summary>
            <param name="sectionName">Name of section to get</param>
            <param name="sectionNumber">Number of section with that name to get. 1-based</param>
        </member>
        <member name="M:DHI.PFS.PFSSection.GetSection(System.String,System.Int32,System.Boolean)">
            <summary>
            Get the n'ths section instance with the specified name.
            <para>
            To get the first section of a certain name, use
            <code>
            section.GetSection("sectionName", 1, true);
            </code>
            </para>
            </summary>
            <param name="sectionName">Name of section to get</param>
            <param name="sectionNumber">Number of section with that name to get.</param>
            <param name="mandatory">If set to true a PFSException will be thrown in case the section does not exist</param>
            <returns>PFSSection, null if not found.</returns>
        </member>
        <member name="M:DHI.PFS.PFSSection.GetSectionsCount(System.String)">
            <summary>
            Get the number of sub-section of this section with the specified section name.
            </summary>
            <param name="sectionName">Name of section to count</param>
        </member>
        <member name="M:DHI.PFS.PFSSection.FindSection(System.String)">
            <summary>
            Find the first section with the given name.
            </summary>
            <param name="sectionName">Name of section to find.</param>
            <returns>A PFSSection, or null if not found.</returns>
        </member>
        <member name="M:DHI.PFS.PFSSection.GetKeywordsCount">
            <summary>
            Get the number of keywords in this section
            </summary>
            <returns>Total number of keywords</returns>
        </member>
        <member name="M:DHI.PFS.PFSSection.GetKeyword(System.Int32)">
            <summary>
            Get the keyword at the specified position.
            </summary>
            <param name="keywordNo">Number of keyword to get. 1-based</param>
        </member>
        <member name="M:DHI.PFS.PFSSection.GetKeyword(System.String)">
            <summary>
            Get the first keyword with the specified name.
            </summary>
            <param name="keywordName">Name of keyword</param>
        </member>
        <member name="M:DHI.PFS.PFSSection.GetKeyword(System.String,System.Int32)">
            <summary>
            Get the n'th keyword instance with the specified name.
            </summary>
            <param name="keywordName">Name of keyword</param>
            <param name="keywordNo">Number of keyword with that name to get. 1-based</param>
        </member>
        <member name="M:DHI.PFS.PFSSection.GetKeyword(System.String,System.Int32,System.Boolean)">
            <summary>
            Get the n'th keyword instance with the specified name.
            </summary>
            <param name="keywordName">Name of keyword</param>
            <param name="keywordNo">Number of keyword with name to get.</param>
            <param name="mandatory">If set to true a PFSException will be thrown in case the keyword does not exist</param>
            <returns>PFSKeyword, null if not found.</returns>
        </member>
        <member name="M:DHI.PFS.PFSSection.GetKeywordsCount(System.String)">
            <summary>
            Get the number of keywords in this section matching KeywordName
            </summary>
            <param name="keywordName">Keyword name to count</param>
            <returns>Number of matching keywords, zero if not found.</returns>
        </member>
        <member name="M:DHI.PFS.PFSSection.DeleteKeyword(System.Int32)">
            <summary>
            Delete a keyword from this section by keyword number
            <para>
            To delete the first keyword in the section, use
            <code>
            section.DeleteKeyword(1)
            </code>
            </para>
            </summary>
            <param name="keywNumber">Number of keyword to delete. 1-based</param>
        </member>
        <member name="M:DHI.PFS.PFSSection.DeleteKeyword(System.String,System.Int32)">
            <summary>
            Delete a keyword from this section by keyword name and named index
            <para>
            To delete the first keyword with some name, use
            <code>
            section.DeleteKeyword("keywordName", 1)
            </code>
            </para>
            </summary>
            <param name="keywName">Name of keyword to delete.</param>
            <param name="keywNumber">Number of keyword with name to delete. 1-based</param>
        </member>
        <member name="M:DHI.PFS.PFSSection.InsertNewKeyword(System.String,System.Int32)">
            <summary>
            Insert a new keyword with specified name into this section object
            <para>
            To Insert a keyword delete the first keyword with some name, use
            <code>
            PFSKeyword keyw = section.InsertNewKeyword("keywordName", 1)
            </code>
            </para>
            </summary>
            <param name="keywName">Name of new keyword</param>
            <param name="position">Position of new keyword within section, 1-based index</param>
            <returns></returns>
        </member>
        <member name="M:DHI.PFS.PFSSection.DeleteSection(System.Int32)">
            <summary>
            Delete a section from this section object by section index
            </summary>
            <param name="sectionNumber">Number of section, 1-based</param>
        </member>
        <member name="M:DHI.PFS.PFSSection.DeleteSection(System.String,System.Int32)">
            <summary>
            Delete a section from this section object by section name and named index
            </summary>
            <param name="sectName">Name of section to delete</param>
            <param name="sectionNumber">Number of section with that name to delete, 1 based</param>
        </member>
        <member name="M:DHI.PFS.PFSSection.InsertNewSection(System.String,System.Int32)">
            <summary>
            Insert a new section with specified name into this section object
            </summary>
            <param name="sectName">Name of new section</param>
            <param name="position">Position of new section, 1-based index</param>
            <returns>The newly created section</returns>
        </member>
        <member name="M:DHI.PFS.PFSSection.ModifyName(System.String)">
            <summary>
            Modify the name of this section
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSSection.GetInstanceNo">
            <summary>
            Internal method, for testing/debugging only
            </summary>
        </member>
        <member name="P:DHI.PFS.PFSSection.Name">
            <summary>
            Name of section.
            </summary>
        </member>
        <member name="P:DHI.PFS.PFSSection.Item(System.Int32)">
            <summary>
            Get the section at the specified index.
            <para>
            Short of <see cref="M:DHI.PFS.PFSSection.GetSection(System.Int32)"/>, as in
            <code>
            GetSection(sectionIndex+1);
            </code>
            </para>
            </summary>
            <param name="sectionIndex">Index of section to get. 0-based</param>
        </member>
        <member name="P:DHI.PFS.PFSSection.Item(System.String,System.Int32)">
            <summary>
            Get the n'th section with the specified name
            <para>
            Short of <see cref="M:DHI.PFS.PFSSection.GetSection(System.String,System.Int32,System.Boolean)"/> as 
            <code>
            GetSection(sectionName, sectionNameIndex+1, false);
            </code>
            </para>
            </summary>
            <param name="sectionName">Name of section to get</param>
            <param name="sectionNameIndex">Index of section with name to get. 0-based</param>
            <returns>PFSSection, null if not found.</returns>
        </member>
        <member name="P:DHI.PFS.PFSSection.Item(System.String)">
            <summary>
            Get the first section with the specified name
            <para>
            Short of <see cref="M:DHI.PFS.PFSSection.GetSection(System.String,System.Int32,System.Boolean)"/> as 
            <code>
            GetSection(sectionName, 1, false);
            </code>
            </para>
            </summary>
            <param name="sectionName">Name of section to get</param>
            <returns>PFSSection, null if not found.</returns>
        </member>
        <member name="T:DHI.PFS.IPFSBuilder">
            <summary>
            The <see cref="T:DHI.PFS.IPFSBuilder"/> is an interface for building a PFS structure or file
            in a "line by line" manner.
            </summary>
        </member>
        <member name="M:DHI.PFS.IPFSBuilder.AddTarget(System.String)">
            <summary>
            Add a new target (top-level section) to a parameter file object. 
            <para>
            This function is always the first function to be called,
            and the target definition must be terminated by a pfsEndSection.
            </para>
            <para>
            A target is ended by calling <see cref="M:DHI.PFS.PFSBuilder.EndSection"/>
            </para>
            <para>
            Restrictions:  Possible previous targets must be have been properly
            terminated by calls to pfsEndSection.
            </para>
            </summary>
            <param name="targetName">Name of target to add</param>
        </member>
        <member name="M:DHI.PFS.IPFSBuilder.AddSection(System.String)">
            <summary>
            Start a new section within the scope of a target/section
            </summary>
            <param name="sectionName">Name of section to add</param>
        </member>
        <member name="M:DHI.PFS.IPFSBuilder.EndSection">
            <summary>
            Terminate a target or a section. 
            <para>
            Restrictions: Each pfsEndSection must match a pfsAddTarget or a pfsAddSection. 
            </para>
            </summary>
            <remarks>
            In a few situations pfsEndSection may be legally omitted, but it is
            recommended never to use this property.
            </remarks>
        </member>
        <member name="M:DHI.PFS.IPFSBuilder.AddKeyword(System.String)">
            <summary>
            Add a keyword to a section, ie the start of a list of parameter list. 
            <para>
            This function is used to define the start of a list of parameters.
            It has no end-counterpart, and the keyword scope is automaticalle "ended" 
            by any other keyword or section related method.
            </para>
            <para>
            Restrictions:  This function must be called within the scope of a section. 
            </para>
            </summary>
            <param name="keyName">Name of keyword to add.</param>
        </member>
        <member name="M:DHI.PFS.IPFSBuilder.AddUndefinedPar">
            <summary>
            Add an undefined parameter to keyword.
            <para>
            Undefined can mean different things for different applications, though the most common is
            "use default value". Before using the undefined parameter, be sure that the model/tool
            that uses the PFS file supports handling undefined parameters.
            </para>
            <para>
            Restrictions: The function is only valid within the scope of a keyword. 
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.IPFSBuilder.AddDouble(System.Double)">
            <summary>
            Add a double precision floating-point (real) value to keyword. 
            <para>
            The output format is some 'default' format. Check if it may cause loss of precision.
            </para>
            <para>
            Restrictions:  The function is only valid within the scope of a keyword. 
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.IPFSBuilder.AddBool(System.Boolean)">
            <summary>
            Add a Boolean value to keyword.
            <para>
            The Boolean value is written true or false.
            </para>
            <para>
            Restrictions:  The function is only valid within the scope of a keyword. 
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.IPFSBuilder.AddInt(System.Int32)">
            <summary>
            Add a four-byte integer to keyword.
            <para>
            Restrictions: The function is only valid within the scope of a keyword 
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.IPFSBuilder.AddString(System.String)">
            <summary>
            Add a null-terminated character string to keyword. 
            <para>
            Restrictions: The function is only valid within the scope of a keyword. 
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.IPFSBuilder.AddFileName(System.String)">
            <summary>
            Add a filename (string) value parameter to keyword.
            <para>
            A file name string is in general a relative path string, relative to the pfs file at hand. 
            If an absolute file name is entered, the PFS system will try to make the path relative to 
            the pfs file, when the pfs file is written to disc, hence the relative string value in the
            PFS file will depend on the location of the pfs file for absolute file names.
            </para>
            <para>
            Restrictions: The function is only valid within the scope of a keyword. 
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.IPFSBuilder.AddClob">
            <summary>
            Add a Clob parameter to keyword
            <para>
            Restrictions: The function is only valid within the scope of a keyword. 
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.IPFSBuilder.AddClobBool(System.Boolean)">
            <summary>
            Add a bool value to the current Clob parameter.
            <para>
            Restrictions: The function is only valid within the scope of a Clob. 
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.IPFSBuilder.AddClobInt(System.Int32)">
            <summary>
            Add an integer (4 byte) value to the current Clob parameter.
            <para>
            Restrictions: The function is only valid within the scope of a Clob. 
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.IPFSBuilder.AddClobFloat(System.Single)">
            <summary>
            Add a single precision floating-point (real) value to Clob. 
            <para>
            Restrictions: The function is only valid within the scope of a Clob. 
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.IPFSBuilder.AddClobDouble(System.Double)">
            <summary>
            Add a double precision floating-point (real) value to Clob. 
            <para>
            Restrictions: The function is only valid within the scope of a Clob. 
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.IPFSBuilder.AddClobString(System.String)">
            <summary>
            Add a string value to Clob. 
            <para>
            Restrictions: The function is only valid within the scope of a Clob. 
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.IPFSBuilder.AddClobFilename(System.String)">
            <summary>
            Add a file name value to Clob. 
            <para>
            Restrictions: The function is only valid within the scope of a Clob. 
            </para>
            </summary>
        </member>
        <member name="T:DHI.PFS.PFSBuilder">
             <summary>
             The <see cref="T:DHI.PFS.PFSBuilder"/> is a class that can build a PFS structure 
             in a "line by line" manner.
             </summary>
             <example>
             Example on writing a simple PFS file:
             <code>
              PFSBuilder builder = new PFSBuilder();
              builder.AddTarget("Run11");
              // Add keyword and parameters
              builder.AddKeyword("key1");
              builder.AddInt(2);
              builder.AddBool(true);
              // Add keyword and parameters in once call
              builder.AddKeywordValues("key2", 3.3, 4, "someText");
            
              // Add subsections
              builder.AddSection("Results");
              builder.AddSection("Result");
              builder.AddKeywordValues("outid", "default out");
              // File name parameter
              builder.AddKeyword("file");
              builder.AddFileName(@".\output.res11");
              builder.EndSection();
              builder.EndSection();
            
              // End target section (Run11)
              builder.EndSection();
             </code>
             </example>
        </member>
        <member name="M:DHI.PFS.PFSBuilder.#ctor">
            <summary>
            Creates a new PFSFile object.
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSBuilder.Write(System.String)">
            <summary>
            Write the contents of a PFS object to file
            </summary>
            <param name="filePath">File Name</param>
        </member>
        <member name="M:DHI.PFS.PFSBuilder.AddTarget(System.String)">
            <inheritdoc />
        </member>
        <member name="M:DHI.PFS.PFSBuilder.AddSection(System.String)">
            <inheritdoc />
        </member>
        <member name="M:DHI.PFS.PFSBuilder.EndSection">
            <inheritdoc />
        </member>
        <member name="M:DHI.PFS.PFSBuilder.AddKeyword(System.String)">
            <inheritdoc />
        </member>
        <member name="M:DHI.PFS.PFSBuilder.AddDouble(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:DHI.PFS.PFSBuilder.AddBool(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DHI.PFS.PFSBuilder.AddInt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.PFS.PFSBuilder.AddString(System.String)">
            <inheritdoc />
        </member>
        <member name="M:DHI.PFS.PFSBuilder.AddFileName(System.String)">
            <inheritdoc />
        </member>
        <member name="M:DHI.PFS.PFSBuilder.AddUndefinedPar">
            <inheritdoc />
        </member>
        <member name="M:DHI.PFS.PFSBuilder.AddClob">
            <inheritdoc />
        </member>
        <member name="M:DHI.PFS.PFSBuilder.AddClobBool(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DHI.PFS.PFSBuilder.AddClobInt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.PFS.PFSBuilder.AddClobFloat(System.Single)">
            <inheritdoc />
        </member>
        <member name="M:DHI.PFS.PFSBuilder.AddClobDouble(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:DHI.PFS.PFSBuilder.AddClobString(System.String)">
            <inheritdoc />
        </member>
        <member name="M:DHI.PFS.PFSBuilder.AddClobFilename(System.String)">
            <inheritdoc />
        </member>
        <member name="T:DHI.PFS.PFSKeyword">
            <summary>
            A PFSKeword object contains a list of parameters. 
            <para>
            Several PFSKeywords can have equal names and different parameters.
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSKeyword.#ctor(System.IntPtr)">
            <summary>
            Initialize a new PFSKeyword with the given pfsNode pointer.
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:DHI.PFS.PFSKeyword.GetParameter(System.Int32)">
            <summary>
            Get the parameter number specified.
            </summary>
            <param name="parameterNo">The number of the parameter to get (1-based)</param>
            <returns>A PFSParameter</returns>
        </member>
        <member name="M:DHI.PFS.PFSKeyword.GetParametersCount">
            <summary>
            Return the number of parameters of this KeyWord.
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSKeyword.DeleteParameter(System.Int32)">
            <summary>
            Delete a parameter from this keyword by parameter position
            </summary>
            <param name="parameterNumber">Number of parameter. 1-based</param>
        </member>
        <member name="M:DHI.PFS.PFSKeyword.InsertNewParameterBool(System.Boolean,System.Int32)">
            <summary>
            Insert a bool parameter into this keyword at the specified position.
            <para>
            If insertion point equals <see cref="P:DHI.PFS.PFSKeyword.Count"/>+1, the parameter is added to the end of the list.
            </para>
            <para>
            Parameters at and after the insertion point move down to accomodate the new element. 
            </para>
            <para>
            This method is an O(n) operation, where n is number of parameters
            </para>
            </summary>
            <param name="val">Value to insert</param>
            <param name="parameterNumber">Parameter position to insert values at. 1-based</param>
            <returns>New parameter</returns>
        </member>
        <member name="M:DHI.PFS.PFSKeyword.InsertNewParameterInt(System.Int32,System.Int32)">
            <summary>
            Insert a integer parameter into this keyword at the specified position.
            <para>
            If insertion point equals <see cref="P:DHI.PFS.PFSKeyword.Count"/>+1, the parameter is added to the end of the list.
            </para>
            <para>
            Parameters at and after the insertion point move down to accomodate the new element. 
            </para>
            <para>
            This method is an O(n) operation, where n is number of parameters
            </para>
            </summary>
            <param name="val">Value to insert</param>
            <param name="parameterNumber">Parameter position to insert values at. 1-based</param>
            <returns>New parameter</returns>
        </member>
        <member name="M:DHI.PFS.PFSKeyword.InsertNewParameterDouble(System.Double,System.Int32)">
            <summary>
            Insert a double parameter into this keyword at the specified position.
            <para>
            If insertion point equals <see cref="P:DHI.PFS.PFSKeyword.Count"/>+1, the parameter is added to the end of the list.
            </para>
            <para>
            Parameters at and after the insertion point move down to accomodate the new element. 
            </para>
            <para>
            This method is an O(n) operation, where n is number of parameters
            </para>
            </summary>
            <param name="val">Value to insert</param>
            <param name="parameterNumber">Parameter position to insert values at. 1-based</param>
            <returns>New parameter</returns>
        </member>
        <member name="M:DHI.PFS.PFSKeyword.InsertNewParameterString(System.String,System.Int32)">
            <summary>
            Insert a string parameter into this keyword at the specified position.
            <para>
            If insertion point equals <see cref="P:DHI.PFS.PFSKeyword.Count"/>+1, the parameter is added to the end of the list.
            </para>
            <para>
            Parameters at and after the insertion point move down to accomodate the new element. 
            </para>
            <para>
            This method is an O(n) operation, where n is number of parameters
            </para>
            </summary>
            <param name="val">Value to insert</param>
            <param name="parameterNumber">Parameter position to insert values at. 1-based</param>
            <returns>New parameter</returns>
        </member>
        <member name="M:DHI.PFS.PFSKeyword.InsertNewParameterFileName(System.String,System.Int32)">
            <summary>
            Insert a file name parameter into this keyword at the specified position.
            <para>
            If insertion point equals <see cref="P:DHI.PFS.PFSKeyword.Count"/>+1, the parameter is added to the end of the list.
            </para>
            <para>
            Parameters at and after the insertion point move down to accomodate the new element. 
            </para>
            <para>
            This method is an O(n) operation, where n is number of parameters
            </para>
            </summary>
            <param name="val">Value to insert</param>
            <param name="parameterNumber">Parameter position to insert values at. 1-based</param>
            <returns>New parameter</returns>
        </member>
        <member name="M:DHI.PFS.PFSKeyword.InsertNewParameterClob(System.Int32)">
            <summary>
            Insert a Clob parameter into this keyword at the specified position.
            The new Clob parameter is returned, and can be populated with data.
            <para>
            If insertion point equals <see cref="P:DHI.PFS.PFSKeyword.Count"/>+1, the parameter is added to the end of the list.
            </para>
            <para>
            Parameters at and after the insertion point move down to accomodate the new element. 
            </para>
            <para>
            This method is an O(n) operation, where n is number of parameters
            </para>
            </summary>
            <param name="parameterNumber">Parameter position to insert values at. 1-based</param>
            <returns>New parameter</returns>
        </member>
        <member name="M:DHI.PFS.PFSKeyword.InsertNewParameterUndefined(System.Int32)">
            <summary>
            Insert a undefined parameter into this keyword at the specified position.
            <para>
            If insertion point equals <see cref="P:DHI.PFS.PFSKeyword.Count"/>+1, the parameter is added to the end of the list.
            </para>
            <para>
            Parameters at and after the insertion point move down to accomodate the new element. 
            </para>
            <para>
            This method is an O(n) operation, where n is number of parameters
            </para>
            </summary>
            <param name="parameterNumber">Parameter position to insert values at. 1-based</param>
            <returns>New parameter</returns>
        </member>
        <member name="M:DHI.PFS.PFSKeyword.ModifyName(System.String)">
            <summary>
            Modify the name of this keyword
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSKeyword.GetInstanceNo">
            <summary>
            Internal method, for testing/debugging only
            </summary>
        </member>
        <member name="P:DHI.PFS.PFSKeyword.Name">
            <summary>
            Name of Keyword.
            </summary>
        </member>
        <member name="P:DHI.PFS.PFSKeyword.Count">
            <summary>
            Return the number of parameters of this KeyWord.
            </summary>
        </member>
        <member name="P:DHI.PFS.PFSKeyword.Item(System.Int32)">
            <summary>
            Get the parameter at the specified index.
            <para>
            Short of <see cref="M:DHI.PFS.PFSKeyword.GetParameter(System.Int32)"/>(parameterIndex+1)
            </para>
            </summary>
            <param name="parameterIndex">The index of the parameter to get</param>
            <returns>A PFSParameter</returns>
        </member>
        <member name="T:DHI.PFS.PFSExtensions">
            <summary>
            Static class, providing a set of help or convenience functionality 
            in the form of extension methods.
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSExtensions.AddDouble(DHI.PFS.IPFSBuilder,System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Add a number of double precision floating-point (real) values. 
            <para>
            The output format is some 'default' format. Check if it may cause loss of precision.
            </para>
            <para>
            Restrictions:  The function is only valid within the scope of a keyword. 
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSExtensions.AddDouble(DHI.PFS.IPFSBuilder,System.Double[])">
            <summary>
            Add a number of double precision floating-point (real) values. 
            <para>
            The output format is some 'default' format. Check if it may cause loss of precision.
            </para>
            <para>
            Restrictions:  The function is only valid within the scope of a keyword. 
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSExtensions.AddInt(DHI.PFS.IPFSBuilder,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Add a number of four-byte integer.
            <para>
            Restrictions: The function is only valid within the scope of a keyword 
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSExtensions.AddInt(DHI.PFS.IPFSBuilder,System.Int32[])">
            <summary>
            Add a number of four-byte integer.
            <para>
            Restrictions: The function is only valid within the scope of a keyword 
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSExtensions.AddDateTime(DHI.PFS.IPFSBuilder,System.DateTime)">
            <summary>
            Add a date and time as 6 integers (year, month, day, hours, minutes, seconds).
            <para>
            Restrictions: The function is only valid within the scope of a keyword. 
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSExtensions.AddDate(DHI.PFS.IPFSBuilder,System.DateTime)">
            <summary>
            Add a date as 3 integers (yyyy, MM, dd). The time part is ignored
            <para>
            Restrictions: The function is only valid within the scope of a keyword. 
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSExtensions.AddTime(DHI.PFS.PFSBuilder,System.DateTime)">
            <summary>
            Add a time as 3 integers (hours, minutes, seconds). The date part is ignored
            <para>
            Restrictions: The function is only valid within the scope of a keyword. 
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSExtensions.AddKeywordValues(DHI.PFS.IPFSBuilder,System.String,System.Object[])">
            <summary>
            Define a keyword, and adds a number of default type of parameters.
            A convenience method that will call the appropriate Add method
            for the provided type.
            <para>
            Each parameter must be one of the types:
            <list type="bullet">
            <item>bool: <see cref="M:DHI.PFS.IPFSBuilder.AddBool(System.Boolean)"/></item>
            <item>int or uint: <see cref="M:DHI.PFS.IPFSBuilder.AddInt(System.Int32)"/></item>
            <item>float or double: <see cref="M:DHI.PFS.IPFSBuilder.AddDouble(System.Double)"/></item>
            <item>string: <see cref="M:DHI.PFS.IPFSBuilder.AddString(System.String)"/></item>
            <item>DateTime: <see cref="M:DHI.PFS.PFSExtensions.AddDateTime(DHI.PFS.IPFSBuilder,System.DateTime)"/></item>
            </list>
            It can not handle filenames and CLOBs.
            </para>
            <para>
            Restrictions: This function must be called within the scope of a section. 
            </para>
            </summary>
            <param name="builder">Builder to add keywords to</param>
            <param name="keyName">Name of keyword to add</param>
            <param name="values">Values/parameters for keyword</param>
        </member>
        <member name="M:DHI.PFS.PFSExtensions.FindSection(DHI.PFS.PFSFile,System.String)">
            <summary>
            Look in all targets of the pfs file and try find a section
            with the provided section name. It will not recurse into sub-sections,
            but only "level-2" sections are looked for.
            </summary>
            <param name="pfsFile">PFS file object</param>
            <param name="sectionName">Name of section to search for</param>
            <returns>Section, null if not found.</returns>
        </member>
        <member name="T:DHI.PFS.PFSParameter">
            <summary>
            A PFSParameter object refers to one single parameter of a Keyword.
            <para>
            Every parameter contains one type of value in it.
            It is the users responsibility to call the get value function matching
            the type of the parameter. If the parameter is an integer, and
            ToDouble() is called, an exception is thrown.
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSParameter.#ctor(System.IntPtr)">
            <summary>
            Initialize a PFSParameter with the given pfs(Node?) pointer.
            </summary>
            <param name="pfsParam"></param>
        </member>
        <member name="M:DHI.PFS.PFSParameter.ToBoolean">
            <summary>
            Get the Boolean value of the parameter
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSParameter.ToInt">
            <summary>
            Get the integer value of the parameter
            <para>
            If this parameter is not an integer parameter, an exception is thrown.
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSParameter.ToDouble">
            <summary>
            Get the double value of the parameter
            <para>
            If this parameter is not a double parameter, an exception is thrown.
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSParameter.ToSingle">
            <summary>
            The the single (float) value of the parameter
            <para>
            If this parameter is not a single/double parameter, an exception is thrown.
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSParameter.ToFileName">
            <summary>
            Get the file name value of the parameter. The returned string is the value as entered in 
            the PFS file, i.e. path can be relative
            <para>
            If this parameter is not a file name parameter, an exception is thrown.
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSParameter.ToFileNamePath">
            <summary>
            Get a string with the filename and path. The returned string will contain the full path to the file. In case the
            file name string is relative, the path of the pfs file is used as base path to create a full path string.
            <para>
            If this parameter is not a file name parameter, an exception is thrown.
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSParameter.ToString">
            <summary>
            Get the string value of the parameter.
            <para>
            If this parameter is not a string parameter, an exception is thrown.
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSParameter.ToResultFileName">
            <summary>
            Get the string or filename value as result-filename. 
            <para>
            A convenience method that for a string returns <see cref="M:DHI.PFS.PFSParameter.ToString"/> 
            and for a filename returns <see cref="M:DHI.PFS.PFSParameter.ToFileName"/>
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSParameter.ToResultFileNamePath">
            <summary>
            Get the result file name path.
            <para>
            The result file name path for relative file name strings depends on whether the 
            underlying pfs parameter is a filename parameter or a string parameter.
            </para>
            <para>
            For a filename parameter, the result file folder is the folder of the pfs file, and a relative 
            file name string is relative to the pfs file location.
            </para>
            <para>
            For a string parameter, the result file folder is taken into consideration when
            creating the path. The result file folder is either the default "pfsFile.pfs - Result Files\",
            the project defined output folder or the custom defined output folder. 
            </para>
            <para>
            The result file name path is always absolute.
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSParameter.ToClob">
            <summary>
            Get the Clob object from the parameter.
            <para>
            If this parameter is not a Clob parameter, an exception is thrown.
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSParameter.IsUndefined">
            <summary>
            Check if this parameter is an undefined parameter
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSParameter.IsBool">
            <summary>
            Check if this parameter is a boolean parameter
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSParameter.IsInt">
            <summary>
            Check if this parameter is an integer parameter
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSParameter.IsDouble">
            <summary>
            Check if this parameter is a double parameter
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSParameter.IsSingle">
            <summary>
            Check if this parameter is a single parameter
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSParameter.IsString">
            <summary>
            Check if this parameter is a string parameter
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSParameter.IsFilename">
            <summary>
            Check if this parameter is a filename parameter
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSParameter.IsClob">
            <summary>
            Check if this parameter is a Blob parameter
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSParameter.ModifyBoolParameter(System.Boolean)">
            <summary>
            Modify the value of this parameter, if it is bool type
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSParameter.ModifyIntParameter(System.Int32)">
            <summary>
            Modify the value of this parameter, if it is int type
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSParameter.ModifyDoubleParameter(System.Double)">
            <summary>
            Modify the value of this parameter, if it is double type
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSParameter.ModifyStringParameter(System.String)">
            <summary>
            Modify the value of this parameter, if it is string type
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSParameter.ModifyFileNameParameter(System.String)">
            <summary>
            Modify the value of this parameter, if it is File Name type
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSParameter.GetInstanceNo">
            <summary>
            Internal method, for testing/debugging only
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSParameter.GetSyntaxClass">
            <summary>
            Internal method, for testing/debugging only
            </summary>
        </member>
        <member name="T:DHI.PFS.PFSFile">
             <summary>
             A PFSFile object is the top level access to a PFS file.
             </summary>
             <example>
             Example of use:
             <code>
               // Load/Read file
               PFSFile pfsFile = new PFSFile(filePath, false);
            
               // Outmost section
               PFSSection target = pfsFile.GetTarget("Run11", 1);
            
               // Sub-sections
               PFSSection section1 = target.GetSection("Results", 1);
               PFSSection section2 = section1.GetSection("Result", 1);
            
               // Keywords and paramters
               string id = section2.GetKeyword("outid", 1).GetParameter(1).ToString();
             </code>
             </example>
        </member>
        <member name="M:DHI.PFS.PFSFile.#ctor(System.String)">
            <summary>
            Load the PFS file given by the filePath.
            </summary>
            <param name="filePath">Filepath of PFSFile to load</param>
        </member>
        <member name="M:DHI.PFS.PFSFile.#ctor(System.String,System.Boolean)">
            <summary>
            Load an existing PFSFile given by the filePath.
            </summary>
            <param name="filePath">Filepath of PFSFile to load</param>
            <param name="silent">defines if possible error messages should be issued automatically or not</param>
        </member>
        <member name="M:DHI.PFS.PFSFile.Finalize">
            <summary>
            Destructor, calls close, in case not called explicitly.
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSFile.GetTargetsCount">
            <summary>
            Return the number of targets present in a parameter file. 
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSFile.GetTarget(System.Int32)">
            <summary>
            Return a reference to the n'th target of a parameter file. 
            </summary>
            <param name="targetNumber">Number of target to get, 1-based index</param>
        </member>
        <member name="M:DHI.PFS.PFSFile.GetTarget(System.Int32,System.Boolean)">
            <summary>
            Return a reference to the n'th target of a parameter file, null if not existing. 
            </summary>
            <param name="targetNumber">Number of target to get, 1-based index</param>
            <param name="mandatory">Set to true if the section must be present</param>
        </member>
        <member name="M:DHI.PFS.PFSFile.GetTarget(System.String,System.Int32)">
            <summary>
            Return a reference to the n'th instance of a specific target name of a parameter file.
            </summary>
            <param name="targetName">Name of target to get</param>
            <param name="targetNumber">Number of target with that name, 1-based index</param>
        </member>
        <member name="M:DHI.PFS.PFSFile.GetTarget(System.String,System.Int32,System.Boolean)">
            <summary>
            Return a reference to the n'th instance of a specific target name of a parameter file, null if not existing
            </summary>
            <param name="targetName">Name of target to get</param>
            <param name="targetNumber">Number of target with that name, 1-based index</param>
            <param name="mandatory">Set to true if the section must be present</param>
        </member>
        <member name="M:DHI.PFS.PFSFile.GetSectionFromHandle(System.String)">
             <summary>
             Try to find the given section based on the sectionPath.
             </summary>
             <param name="sectionPath">the position of the section specified relative from the nPfs node</param>
             <returns>Null if not found</returns>
             <remarks>
             The section path is specified in the form section1/section2/section3. A section
             name can be ".." which means the parent section to the current section.
            
             The section can include a sequence number in the form "name:no" - no gives
             the sequence number of section with the specified name. This is only relevant
             if more than one section at the same level have the same name.
             </remarks>
        </member>
        <member name="M:DHI.PFS.PFSFile.GetResultFolder">
            <summary>
            Evaluatet the actual result folder, based on default result folder,
            <see cref="P:DHI.PFS.PFSFile.ProjectResultFolder"/>, 
            <see cref="P:DHI.PFS.PFSFile.UseCustomResultFolder"/> and
            <see cref="P:DHI.PFS.PFSFile.CustomResultFolder"/>.
            <para>
            The default result folder is the path of the pfs file, followed by 
            <code>"\PfsFileName.pfs - Result Files\"</code>.
            </para>
            <para>
            When a project result folder is defined, the result folder is the
            project result folder, followed by
            <code>"\PfsFileName.pfs - Result Files\"</code>.
            </para>
            <para>
            When a custom result folder is defined, that is the location of the
            result folder.
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSFile.Close">
            <summary>
            Terminate the access to a parameter file data structure and free the associated internal storage. 
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSFile.Close(System.Boolean)">
            <summary>
            Terminate the access to a parameter file data structure and free the associated internal storage. 
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSFile.DeleteTarget(System.Int32)">
            <summary>
            Delete a target section from this pfs file, by section number
            </summary>
            <param name="targetNumber">Number (1-based) of target to delete</param>
        </member>
        <member name="M:DHI.PFS.PFSFile.DeleteTarget(System.String,System.Int32)">
            <summary>
            Delete a target section from this pfs file, by section name and named number
            </summary>
            <param name="targetName">Name of target to delete</param>
            <param name="targetNumber">Number (1-based) of target with name to delete</param>
        </member>
        <member name="M:DHI.PFS.PFSFile.InsertNewTarget(System.String,System.Int32)">
            <summary>
            Insert a new target section with specified name into this pfs file at the specified position
            </summary>
            <param name="targetName">Name of target</param>
            <param name="position">Number to insert new target section at, i.e. the new target section 
            will be positioned as target number, and existing target sections will be moved one position.</param>
            <returns>The newly inserted target section.</returns>
        </member>
        <member name="M:DHI.PFS.PFSFile.Write(System.String)">
            <summary>
            Write the contents of a PFS object to file
            </summary>
            <param name="filePath">File Name</param>
        </member>
        <member name="P:DHI.PFS.PFSFile.Count">
            <summary>
            Return the number of targets present in a parameter file. 
            </summary>
        </member>
        <member name="P:DHI.PFS.PFSFile.Item(System.Int32)">
            <summary>
            Return a reference to the n'th target of a parameter file. 
            <para>
            Short version of <see cref="M:DHI.PFS.PFSFile.GetTarget(System.Int32)"/>
            with <code>GetTarget(targetIndex+1)</code>
            </para>
            </summary>
            <param name="targetIndex">Number of target to get, 0-based index</param>
        </member>
        <member name="P:DHI.PFS.PFSFile.Item(System.String)">
            <summary>
            Return a reference to the first instance of a specific target name of a parameter file.
            <para>
            Short version of <see cref="M:DHI.PFS.PFSFile.GetTarget(System.String,System.Int32)"/>
            with <code>GetTarget(targetName,1)</code>
            </para>
            </summary>
            <param name="targetName">Name of target to get</param>
        </member>
        <member name="P:DHI.PFS.PFSFile.Item(System.String,System.Int32)">
            <summary>
            Return a reference to the n'th instance of a specific target name of a parameter file.
            <para>
            Short version of <see cref="M:DHI.PFS.PFSFile.GetTarget(System.String,System.Int32)"/>
            with <code>GetTarget(targetName, targetIndex+1)</code>
            </para>
            </summary>
            <param name="targetName">Name of target to get</param>
            <param name="targetIndex">Index of target with that name, 0-based index</param>
        </member>
        <member name="P:DHI.PFS.PFSFile.ProjectResultFolder">
            <summary>
            Project result folder. A global result folder defined for the entire
            MzShell project.
            <para>
            Managed by MzShell, when the PFS file is used as part of an 
            open MzShell project
            </para>
            </summary>
        </member>
        <member name="P:DHI.PFS.PFSFile.UseCustomResultFolder">
            <summary>
            Use custom result folder. 
            <para>
            Overrides the <see cref="P:DHI.PFS.PFSFile.ProjectResultFolder"/> with the <see cref="P:DHI.PFS.PFSFile.CustomResultFolder"/>, 
            if the flag is true.
            </para>
            <para>
            Managed by MzShell, when the PFS file is used as part of an 
            open MzShell project
            </para>
            </summary>
        </member>
        <member name="P:DHI.PFS.PFSFile.CustomResultFolder">
            <summary>
            Custom result folder. 
            <para>
            Overrides the <see cref="P:DHI.PFS.PFSFile.ProjectResultFolder"/>, if the <see cref="P:DHI.PFS.PFSFile.UseCustomResultFolder"/>
            flag is true.
            </para>
            <para>
            Managed by MzShell, when the PFS file is used as part of an 
            open MzShell project
            </para>
            </summary>
        </member>
        <member name="T:DHI.PFS.PFSClob">
            <summary>
            Clob is short of Character Large Object.
            <para>
            A Clob can be used to store a multitude of parameters in a single PFS parameter
            e.g. storing vectors/matrices of coordinates. This can save space for the PFS file
            and improve performance of reading and handling the PFS file.
            </para>
            <para>
            Reading data from a Clob works as iterating over a list of parameters. Calling one 
            of the Get methods will return the "current" parameter and forward the iterator to 
            the next parameter in the Clob.
            </para>
            <para>
            The structure of the clob must be known beforehand, i.e. the number of Clob values and the order 
            the different types of values in must match the order of methods called for retrieving the values. If
            that is not the case, an exception is thrown, i.e. if the next value in the Clob is a double, and the
            <see cref="M:DHI.PFS.PFSClob.GetString"/> method is called, an exception is thrown.
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSClob.#ctor(System.IntPtr)">
            <summary>
            Internal constructor
            </summary>
            <param name="pfsClob">Handle to unmanaged PFS Clob object</param>
        </member>
        <member name="M:DHI.PFS.PFSClob.GetBool">
            <summary>
            Read boolean from Clob
            <para>
            If next Clob value is not a boolean, an exception is thrown.
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSClob.GetInt">
            <summary>
            Read integer from Clob
            <para>
            If next Clob value is not an integer, an exception is thrown.
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSClob.GetFloat">
            <summary>
            Read float from Clob
            <para>
            If next Clob value is not a float, an exception is thrown.
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSClob.GetDouble">
            <summary>
            Read double from Clob
            <para>
            If next Clob value is not a double, an exception is thrown.
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSClob.GetString">
            <summary>
            Read string from Clob
            <para>
            If next Clob value is not a string, an exception is thrown.
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSClob.GetFilename">
            <summary>
            Read file name string from Clob
            <para>
            If next Clob value is not a file name string, an exception is thrown.
            </para>
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSClob.GetItem">
            <summary>
            Get the next Clob parameter as a <see cref="T:DHI.PFS.PFSParameter"/>,
            where you can query it for the type of parameter data.
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSClob.IsEnd">
            <summary>
            Returns true of the Clob has no more parameters
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSClob.Reset(System.Boolean)">
            <summary>
            Reset reading of parameters from Clob
            </summary>
        </member>
        <member name="T:DHI.PFS.PFSException">
            <summary>
            Exception that is thrown in case of a failure in PFS system
            or in the use of the PFS system.
            </summary>
        </member>
        <member name="M:DHI.PFS.PFSException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the PFSException class with a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:DHI.PFS.PFSException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the PFSException class with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception, or a null reference if no inner exception is specified.</param>
        </member>
        <member name="P:DHI.PFS.PFSException.PFSNodeName">
            <summary>
            Name of the PFS node (target/section/keyword) that produced the exception.
            </summary>
        </member>
    </members>
</doc>
